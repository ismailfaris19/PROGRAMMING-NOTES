/////////////////////////////////////////////////////////////////////////////////

/////////////  NODEJS  ////////////////////////////

/////////////////////////////////////////////////////////////////////////////////

# NodeJs is a JS runtime built on chrome's V8 JavaScript engine, chakra engine in microsoft and spider monkey in firefox.

# Single threaded but highly scalable(can handle multiple request), very fast and open source.

# 1) node version check : node -v
  2) npm version check: npm -v
  3) run node server: node index
  4) create package.json: npm init (click enter for all)
  5) install all node modules: npm install
  6) install separate node module: npm i <module-name>

# we have the vscode extension to check the APIs. That is "REST Client" extension is used to check the API. After installing the extension, we have to create "api.http" file inside our folder.

# In api.http file, we will use request method name, request url and HTTP version. 
	Syntax: <Request-Method> <Request-URL> <HTTP-Version>
	Eg: GET http://localhost:3500/ HTTP/1.1

# then click "Send Request" to check the response. Separate the API call using "###" for multiple requests.
  
# if we console the module, it will print :
		Module {
			id: '.',
			path: 'D:\\Exercises\\NodeJS\\NodeJS-Demo\\demo',
			exports: {},
			filename: 'D:\\Exercises\\NodeJS\\NodeJS-Demo\\demo\\test.js',
			loaded: false,
			children: [],
			paths: [
				'D:\\Exercises\\NodeJS\\NodeJS-Demo\\demo\\node_modules',
				'D:\\Exercises\\NodeJS\\NodeJS-Demo\\node_modules',     
				'D:\\Exercises\\NodeJS\\node_modules',
				'D:\\Exercises\\node_modules',
				'D:\\node_modules'
			]
		}

# > Example import: let num = require('./demo/test');
  < Example export: let a = 15 // set variable
  				    module.exports = a // export the variable
				    exports.sayAge = () => { // export the function
				  	return a
				    }
					module.exports = { // for two or more exports
						a,
						sayAge
					}

# if we want to import any node module, we don't need to give full path so we just gave the module name.

# if we want to import any file, we have to give full path.

# assign express pre-defined function to this variable
	Eg: const express = require('express');

# assign the return type of the above function. it returns the object which contains many methods.
	Eg: const app = express();

# app.use() - 

# app.listen(<port>, () => <some statement>) - to run the application in localhost with manually specified port.

# app.get('<path>', (req, res) => <response>) - to get the resources from server

# app.post('<path>', (req, res) => <response>) - to add new resource in server

# app.put('<path>', (req, res) => <response>) - to update the resource in server

# app.delete('<path>', (req, res) => <response>) - to remove the resource from server

/////////////////////////////////////////////////////////////////////////////////

/////////////  TYPESCRIPT  ////////////////////////////

/////////////////////////////////////////////////////////////////////////////////

# It's a super set of javascript.

# Strong typing(datatype is optional), object oriented features, compile time errors not a runtime, great tooling

# typescript was translated to javascript by browser engine so browser can understand easily.

# Install typescript : npm install -g typescript
  check version: tsc --version
  translate from Ts to Js: tsc <TS-filename> (new JS file create with same name)

# All Js codes are acceptable in Ts.

# Declare variable syntax: let <var-name> or let <var-name> : <data-type>

# class in typescript must have only one constructor. It will be parameterized or empty constructor.

# In typescript, three access modifiers are public, private, and protected.


/////////////////////////////////////////////////////////////////////////////////

/////////////  ANGULAR  ////////////////////////////

/////////////////////////////////////////////////////////////////////////////////

# Create new app: ng new <app-name>

# Run a app: ng serve --open // run app in http://localhost:4200

# Test a app: ng test

# Build for production: ng build

# Generate component: ng generate component <component-name> 
									(or) 
					  ng g c <component-name>

# Generate module: ng generate module <module-name>
									(or) 
				   ng g m <module-name>

# Generate component under pre-defined module: ng generate component <module-name>/<component-name>
																	(or)
											   ng g c <module-name>/<component-name>

# Generate service: ng generate service <service-name>
								(or)
					ng g s <service-name>

# Generate service under pre-defined module with folder name: ng generate service <module-name>/<service-folder-name>/<service-name>
																	(or)
											 				  ng g s <module-name>/<service-folder-name>/<service-name>


# module - it contains one or more components.


# selector - it is the name of the component which will be used in another components as tag. Eg: selector: 'about-component' // in that component
																								  <about-component> // in other components


# templateUrl - it is the name of the HTML template which contains DOM elements for the component. Eg: 


# app.component.ts	- The component class code, written in TypeScript.


# app.component.html - The component template, written in HTML.


# app.component.css - The component's private CSS styles.


# <app-root> - The first component to load and the container for the other components.


# *ngFor - loop over the array to print elements in a web page.
		Eg: <div *ngFor="let product of products">
				<h3>
					{{ product.name }}
				</h3>
			</div>


# Structure of component:
		Eg: import { Component, OnInit } from '@angular/core';

			@Component({
			selector: 'app-product-alerts',
			templateUrl: './product-alerts.component.html',
			styleUrls: ['./product-alerts.component.css']
			})

			export class ProductAlertsComponent implements OnInit {

			constructor() { }

			ngOnInit() {
			}

			}


# In app.module.ts, enter component names in declarations array and enter module names inside imports array.
		Eg: @NgModule({
			declarations: [
				AppComponent,
				AboutComponent,
				ContactComponent
			],
			imports: [
				BrowserModule,
				AppRoutingModule,
				CustomerModule
			],
			providers: [],
			bootstrap: [AppComponent]
			})


# In app-routing.module.ts, we have to import the components which we want to make routing.
		Eg: import {HomeComponent} from './home/home.component';

			const routes: Routes = [{
				path: 'home',
				component: HomeComponent
			},
			{
				path: '',
				component: HomeComponent
			}];


# In app-routing.module.ts, we don't need to import module for routing between modules.
		Eg:	const routes: Routes = [
			{
				path: 'module-one',
				loadChildren: () =>
				import(`./moduleOne/module-one.module`).then((m) => m.ModuleOneModule),
			},
			{
				path: 'module-two',
				loadChildren: () =>
				import(`./moduleTwo/module-two.module`).then((m) => m.ModuleTwoModule),
			},
			{
				path: 'module-three',
				loadChildren: () =>
				import(`./moduleThree/module-three.module`).then(
					(m) => m.ModuleThreeModule
				),
			},
			{ path: '', redirectTo: 'module-one', pathMatch: 'full' }
			];


# To install and setup Bootstrap:
		$ npm install --save boostrap@3
		$ in angular.json -> above "src/styles.css" -> enter "node_modules/bootstrap/dist/css/bootstrap.min.css"


# To install and setup dataTables:
		$ install those libraries,
			> npm install jquery --save
			> npm install datatables.net --save 
			> npm install datatables.net-dt --save
			> npm install @types/jquery --save-dev 
			> npm install @types/datatables.net --save-dev
			
		$ paste this below content in Angular.json,
			> "styles": [
				"src/styles.css",
				"node_modules/datatables.net-dt/css/jquery.dataTables.min.css",
				"node_modules/bootstrap/dist/css/bootstrap.css"
				],
				"scripts": [
				"node_modules/jquery/dist/jquery.min.js",
				"node_modules/bootstrap/dist/js/bootstrap.js",
				"node_modules/datatables.net/js/jquery.dataTables.min.js"
				]

		$ In component.ts file, paste and change some content,
			> Add this line above @Component and remove import statement to paste this, 	
					import { AfterViewInit, Component, OnInit, ViewChild } from '@angular/core';
					declare var $: (arg0: any) => any;
			> Class must implements OnInit and AfterViewInit,
					export class ListUsersComponent implements OnInit, AfterViewInit{}
			> Paste this below content inside the class, 
					Before the constructor:	@ViewChild('dataTable', { static: false }) table: any;
						                    dataTable: any; 
					After the constructor: ngAfterViewInit(): void {
												this.dataTable = $(this.table.nativeElement);
												this.dataTable.DataTable();
											}	
		$ In component.html, add this "#dataTable" in table tag.
					Eg: <table class="table table-striped p-1" #dataTable></table>


# we don't need to put let (or) const (or) function keywords inside the class


# Interpolation: 
		$ to use dynamic values inside the HTML template
		$ we can access the variable inside the class in component.ts
		$ Eg: {{ num }}, {{ myFunction() }} // in the template
		$ interpolation inside the HTML tags: Eg: <input type="text" placeholder="{{ input_placeholder }}" // input_placeholder is an variable inside the.
		$ interpolation returns only string format.


# Property binding:
		$ syntax : [attribute-name] = " <expression> "
		$ we can use expression inside the HTML Tag.
		$ it will return the same value we pass in class file.
		$ angular can't understand the aria and colspan attributes. so in this place we have to use property binding.


# Class binding: 
		$ syntax : [class] = " <variable-name> " or  [ngClass] = " <variable-name> "
		$ we can add dynamic classes inside the tag.
		$ if we use object name in that variable name it will add the properties as classname which returns true.


# Style binding:
		$ syntax : [style.<property-name>.<value-type-if-needed>] = " <value> " 
		(or) 
		[style] ="'<property-name> : <value>'" 
		(or) 
		[style] = "{
			<property-name> : <value>,
			<property-name> : <value>
		}"
		(or)
		[ngStyle] = "{
			<property-name> : <value>,
			<property-name> : <value>
		}" // in ngStyle we can only use object type
		$ property-name must be in camel case


# Event binding:
		$ syntax: (<Event-name>)="<function-name>"
		$ we can control and get data from webpage using this events
		$ Eg: <button (click)="functionClick()">
		$ we can use e to get value and more details.
			Eg: function functionClick(e: any) {
				console.log(e)
			}


# Two way binding:
		$ Syntax: [(ngModel)] = "<variable-name>" // set as attribute in html tags
		$ we have to import FormsModule in app.module.ts
		$ we can change the value dynamically in webpage. whenever change the value, it will automatically change and render in webpage. 
		$ before two way binding, we have to update the value in elements again.
		$ Eg: Google translate


# Angular Forms:
	$ we have to import FormsModule and ReactiveFormsModule in the modules where we use forms and app.module.
		@ FormControl - all input tags
			> we have to create a variable for each input tag and set attribute in tag.
			> import Validators for validation.
				Eg: email = new FormControl("hello@example.com", [Validators.required, Validators.minLength, Validators.maxLength]);
					<input type="text" name="email" [formControl] = "email"> // this is variable name
			> Inside FormGroup in HTML, it must be enter as formControlName instead of [formControl]
			> Eg: in constructor, this.email.valueChanges.subscribe(data => {
									console.log(data); // single value
								  }) // get values which we enter in a input field
			> Eg: in constructor, this.email.statusChanges.subscribe(ValidOrInvalid => {
									console.log(ValidOrInvalid);
								  }) // get invalid or valid status

		@ FormGroup - form tag
			> We have to create a variable for formgroup and passess value as a object in it.
			> import Validators for validation for each properties in an formgroup.
				Eg: createForm = new FormGroup({
						name: new FormControl("", [Validators.required]),
						email: new FormControl("", [Validators.required]),
					});
					<form class="form" [formGroup]="createForm" (ngSubmit)="onSubmit()">
						<label for="name">Name</label>
						<input type="name" id="name" formControlName = "name">
						<label for="email">Email</label>
						<input type="email"  id="email" formControlName = "email">
						<button type="submit">save</button>
					</form>
			> We have to use form control in every input fields so then only formgroup can validate the values.
			> We have to add ngSubmit attribute with function name in form tag to submit a data as a object form. 
				Eg: (ngSubmit)="onSubmit()".
			> We can the whole value and valid or invalid after submitting the form.
				Eg: onSubmit() {
						console.log(this.createForm.value);
						console.log(this.createForm.valid);
					}
			> Eg: in constructor, this.createForm.valueChanges.subscribe(data => {
									console.log(data); // value is object type
								  }) // get values which we enter in a input field of this form

			> Eg: in constructor, this.createForm.statusChanges.subscribe(ValidOrInvalid => {
									console.log(ValidOrInvalid);
								  }) // it check all the validators in a form and retire invalid or valid status
			> patchValue() - set single value to the form group.
				Syntax: this.<formgroup-name>.patchValue({
					<formcontrol-name> : <value>
				})
			> setValue() - set more than one values to the form group.
				Syntax: this.<formgroup-name>.setValue({
					<formcontrol-name> : <value>,
					<formcontrol-name> : <value>
				})
			> setControl - this is replaces existing control.
				Eg: this.createForm.setControl('nationality', this.formBuilder.control('', [Validators.required]))
			> addControl() - adds a control and updates its value and validity. we may use any abstract control in it.
				Eg: this.createForm.addControl('nationality', new FormControl('', [Validators.required]))
			> removeControl() - remove a control from the form group.
				Eg: this.createForm.removeControl('nationality')
			> contains() - checks if there is any enabled control for the specified control name.
				Eg: this.createForm.contains('nationality')
			> get() - we can access the single property inside a form group.
				Eg: this.createForm.get('nationality')

		@ FormArray - it is array like structure and it may contains FormGroup and FormControl.
			> Eg : fa = new FormArray([])
					<div [formArrayName] = "fa" *ngFor="let item of fa.controls; let i = index">
						<label for="mobile">Mobile {{ i + 1 }}</label>
						<input type="text" id="mobile" [formControlName] = "i">
						<small class="text-danger" *ngIf="mobileArray.controls[i].errors">*Mobile number is required</small>
					</div> 
			> Inside FormGroup in HTML, it must be enter as formArrayName instead of [formArray]
			> push() - using this method to push FormGroup or FormControl inside the array. Eg: this.fa.push(new FormControl('123'))
			> controls - used to get the form array elements. Eg: this.fa.controls

		@ FormBuilder - create and pass object without using form control and form group. Without any change in HTML.
			> It has three methods such as,
				-> group({}) - To create a form group.
				-> control('') - To create a form control.
				-> array([]) - To create a form array.
			> The below example shows the form builder structure(form array + form control).
				Eg: In component.ts, 
					    createForm : FormGroup;
						constructor(private fb: FormBuilder) { 
							this.createForm = this.fb.group({ // this used to create form group
							name: this.fb.control('', [Validators.required]), // this line
							email: ['', [Validators.required]], // and this lines are same to create form control
							mobile: this.fb.array([]) // this is used to create form array
							})
							this.createForm.valueChanges.subscribe(data => {
							console.log(data);
							})
						}
						get mobileArray(){
							return this.createForm.get('mobile') as FormArray;
						}
						viewFormArray(){
							const mobileController = this.fb.control('+91-', Validators.required)
							this.mobileArray.push(mobileController);
							console.log(
							this.mobileArray.controls
							)
						}
						onSubmit() {
							console.log(this.createForm.value);
							console.log(this.createForm.valid);
						}
					In component.html,
						<form class="form d-flex flex-column" [formGroup]="createForm" (ngSubmit)="onSubmit()">
							<label for="name">Name</label>
							<input type="name" id="name" formControlName = "name">
							<label for="email">Email</label>
							<input type="email" id="email" formControlName = "email">
							<div formArrayName = "mobile" *ngFor="let contact of mobileArray.controls; let i = index">
								<label for="mobile">Mobile {{ i + 1 }}</label>
								<input type="text" id="mobile" [formControlName] = "i">
								<small class="text-danger" *ngIf="mobileArray.controls[i].errors">*Mobile number is required</small>
							</div> 
							<button type="submit">save</button>
						</form>
						<button (click) = "viewFormArray()">view</button>
			> The below example shows the form builder structure(form array + form group).
				Eg: In component.ts,
						createForm : FormGroup;
						constructor(private fb: FormBuilder) { 
							this.createForm = this.fb.group({ // this used to create form group
							name: this.fb.control('', [Validators.required]), // this line
							email: ['', [Validators.required]], // and this lines are same to create form control
							address: this.fb.array([]) // this is used to create form array
							})
							this.createForm.valueChanges.subscribe(data => {
							console.log(data); // print createForm object value changes
							})
						}
						get addressArray(){
							return this.createForm.get('address') as FormArray; // Type conversion
						}
						viewFormArray(){
							const addressGroup = this.fb.group({
							doorno: ['', Validators.required],
							street: ['', Validators.required]
							})
							this.addressArray.push(addressGroup); // add value
							console.log(
							this.addressArray.controls // print the array
							)
						}
						removeAddress(index:number){
							this.addressArray.removeAt(index) // remove value at this particular index
						}
						onSubmit() {
							console.log(this.createForm.value);
							console.log(this.createForm.valid);
						}
					In component.html, 
						<form class="form d-flex flex-column" [formGroup]="createForm" (ngSubmit)="onSubmit()">
							<label for="name">Name</label>
							<input type="name" id="name" formControlName = "name">
							<label for="email">Email</label>
							<input type="email" id="email" formControlName = "email">
							<ul class="form d-flex flex-column" formArrayName = "address">
								<li class="form d-flex flex-column"  *ngFor="let address of addressArray.controls; let i = index" [formGroupName]="i">
									<label for="address">Address {{ i + 1 }}</label>
									<input type="text" placeholder="Door No." formControlName = "doorno">
									<small class="text-danger" *ngIf="addressArray.controls[i].get('doorno')?.touched && addressArray.controls[i].get('doorno')?.errors">*Door number is required</small> // touched is used for check click inside a input field and then click outside input field without enter anything.
									<input type="text" placeholder="Street" formControlName = "street">
									<small class="text-danger" *ngIf="addressArray.controls[i].get('street')?.touched && addressArray.controls[i].get('street')?.errors">*Street is required</small>
									<button (click)="removeAddress(i)">Remove Address</button>
								</li>
							</ul>
							<button type="submit">save</button>
						</form>
						<button (click) = "viewFormArray()">Add Address</button>
						

# Using "as" keyword to do type conversion. In below example, we converted from formcontrol to formarray.
	Eg: this.createForm.get('mobile') as FormArray 

# Input field events:
	$ touched - this event occurs when user click inside a input field and then click outside input field without enter anything.
	$ dirty - this event occurs when user type in a input field
